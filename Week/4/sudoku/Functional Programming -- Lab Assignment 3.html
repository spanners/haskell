
<!-- saved from url=(0062)http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Functional Programming  -- Lab Assignment 3 </title>
<link rel="stylesheet" type="text/css" href="./Functional Programming -- Lab Assignment 3_files/saved_resource">
<style type="text/css"></style></head>

<body>

<table width="100%" bgcolor="#BBBBBB" border="0" cellpadding="5">
<tbody><tr>
<td align="left">
<font size="+2">
Functional Programming -- Lab Assignment 3
</font>
</td>
<td align="right">
<font size="+1">
TDA452 &amp; DIT142 | LP2 | HT2012 | [<a href="./Functional Programming -- Lab Assignment 3_files/saved_resource">Home</a>] 
</font>
</td>
</tr>
</tbody></table>
<hr>

<!-- ---------------------------------------------------------------------- -->


<p>

</p><h2>Lab Assignment 3 -- Sudoku</h2>

<p>

Some notes:
</p><menu>
<p></p><li>Remember that you have to work in pairs. <b>Only groups of size 2 are allowed to submit!</b> Submissions by only 1 person or 3 or more persons
will not be accepted by the Fire system.
<p></p></li><li><a href="https://fire.cs.chalmers.se:8073/cgi/Fire-fp">When you are done, 
please submit your solution using the
Fire
system.</a>
<p></p></li><li>If you are stuck on this assignment, please read the page on <a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/help.html">Getting Help</a> carefully!
</li></menu>
Good luck!

<p>
</p><hr>
<p>

<font size="+2">Lab Assignment 3 -- Sudoku</font><br>
</p><p>

In this Lab Assignment, you will design a Haskell program that will be able
to solve Sudokus, a popular logical puzzle originating from Japan.

</p><p>
<b>Assignments and Deadlines</b>
</p><p>

There are 6 regular assignments as part of this Lab: A, B, C, D, E, and F. The
lab consists (again) of two parts.

</p><p>

For submission, assignments A, B, C and D are called <b>Lab 3A</b>. 
</p><p>

Assignments
E and F are called <b>Lab 3B</b>. 
</p><p>
Deadlines for each of these parts are given on the <a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/">home page</a>.

There are also <a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/extra.html">extra assignments</a>. You can choose freely
whether to do one of these. Those are just for fun. 
</p><p>
<b>Hints</b>
</p><p>
Some assignments have hints. Often, these involve particular standard Haskell
functions that you could use. Some of these functions are defined in modules
that you have to import yourself explicitly. You can use the following
resources to find more information about those functions:

</p><menu>
<p></p><li><a href="http://haskell.org/hoogle/">Hoogle</a>, the library function search engine
<p></p></li><li><a href="http://cvs.haskell.org/Hugs/pages/libraries/">Haskell Library
Structure</a>, all standard libraries, for you to browse (scroll down to heading
"Modules")
<p></p></li><li><a href="http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html">A Tour of the Haskell Prelude</a> shows all standard Haskell functions that you
get without importing any module
</li></menu>

We encourage you to actually go and find information about the functions that
are mentioned in the hints!

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Sudokus</font><br>
<p>

Sudoku is a logic puzzle originating in Japan. In the West
it has caught on in popularity enormously over the last five years or so. Most
newspapers now publish a daily Sudoku puzzle for the readers to solve.

</p><p>

A Sudoku puzzle consists of a 9x9 grid. Some of the cells in the grid have
digits (from 1 to 9), others are blank. The objective of the puzzle is to fill
in the blank cells with digits from 1 to 9, in such a way that every row, every
column and every 3x3 block has exactly one occurrence of each digit 1 to 9.

</p><p>

Here is an example of a Sudoku puzzle:

</p><p>

<img align="CENTER" src="./Functional Programming -- Lab Assignment 3_files/example.gif">

</p><p>

And here is the solution:

</p><p>

<img align="CENTER" src="./Functional Programming -- Lab Assignment 3_files/solution.gif">

</p><p>

In this lab assignment, you will write a Haskell program that can read in a
Sudoku puzzle and solve it.

</p><p>
<b>More Information</b>
</p><p>

If you want to read more about Sudokus, here are a few links:

</p><menu>
<p></p><li>The <a href="http://www.dailysudoku.com/sudoku/index.shtml">Daily Sudoku</a> has examples and explanations
<p></p></li><li><a href="http://en.wikipedia.org/wiki/Sudoku">Wikipedia on Sudoku</a>
<p></p></li><li><a href="http://www.sudoku.com/">sudoku.com</a> has examples and
explanations
<p></p></li><li><a href="http://sudoku.com.au/">sudoku.com.au</a> has sudoku
puzzles that you can solve online
</li></menu>

<p>

<!-- -------------------------------------------------------------------- -->

</p><p><br></p><hr>
<font size="+2">Modelling Sudokus</font><br>
<p>

To implement a Sudoku-solving program, we need to come up with a way of
modelling Sudokus. A Sudoku is a matrix of digits or blanks. The natural way of
modelling a matrix is as a list of lists. The outer list represents all the
rows, and the elements of the list are the elements of each row. Digits or
blanks can be represented by using the Haskell <b>Maybe</b> type. Digits are
simply represented by <b>Int</b>.

</p><p>

Summing up, a natural way to represent Sudokus is using the following Haskell
datatype:

</p><pre>  <b>data</b> Sudoku = Sudoku [[Maybe Int]]
</pre>

Since it is convenient to have a function that extracts the actual rows from the
Sudoku, we actually use the following equivalent datatype definition:

<pre>  <b>data</b> Sudoku = Sudoku { rows :: [[Maybe Int]] }
</pre>

For example, the above Sudoku puzzle has the following representation in Haskell:

<pre>  example :: Sudoku
  example =
    Sudoku
      [ [Just 3, Just 6, Nothing,Nothing,Just 7, Just 1, Just 2, Nothing,Nothing]
      , [Nothing,Just 5, Nothing,Nothing,Nothing,Nothing,Just 1, Just 8, Nothing]
      , [Nothing,Nothing,Just 9, Just 2, Nothing,Just 4, Just 7, Nothing,Nothing]
      , [Nothing,Nothing,Nothing,Nothing,Just 1, Just 3, Nothing,Just 2, Just 8]
      , [Just 4, Nothing,Nothing,Just 5, Nothing,Just 2, Nothing,Nothing,Just 9]
      , [Just 2, Just 7, Nothing,Just 4, Just 6, Nothing,Nothing,Nothing,Nothing]
      , [Nothing,Nothing,Just 5, Just 3, Nothing,Just 8, Just 9, Nothing,Nothing]
      , [Nothing,Just 8, Just 3, Nothing,Nothing,Nothing,Nothing,Just 6, Nothing]
      , [Nothing,Nothing,Just 7, Just 6, Just 9, Nothing,Nothing,Just 4, Just 3]
      ]
</pre>

Now, a number of assignments follows, which will lead you step-by-step towards
an implementation of a Sudoku-solver.

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Some Basic Sudoku Functions</font><br>
<p>

To warm up, we start with a number of basic functions on Sudukos.

</p><p>

<b>Assignment A</b>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>A1.</b> Implement a function
<pre>  allBlankSudoku :: Sudoku
</pre>
that represents a Sudoku that only contains blank cells (this means that no
digits are present).
<p>
Do not use copy-and-paste programming here! Your definition does not need to be longer than
a few short lines.
</p></td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>A2.</b> The Sudoku type we have defined allows for more things than Sudokus.
For example, there is nothing in the type definition that says that a
Sudoku has 9 rows and 9 columns,
or that digits need to lie between 1 and 9. Implement a function
<pre>  isSudoku :: Sudoku -&gt; Bool
</pre>
that checks if all such extra conditions are met by the given Sudoku.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>isSudoku (Sudoku [])</em>
  False
  <b>Sudoku&gt;</b> <em>isSudoku allBlankSudoku</em>
  True
  <b>Sudoku&gt;</b> <em>isSudoku example</em>
  True
  <b>Sudoku&gt;</b> <em>isSudoku (Sudoku (tail (rows example)))</em>
  False
</pre>
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>A3.</b> Our job is to solve Sudokus. So, it would be handy to know
when a Sudoku is solved or not. We say that a Sudoku is solved if there
are no blank cells left to be filled in anymore. Implement the following
function:
<pre>  isSolved :: Sudoku -&gt; Bool
</pre>
Note that we do not check here if the Sudoku is a <em>valid</em> solution; we
will do this later. This means that any Sudoku without blanks (even Sudokus with
the same digit appearing twice in a row) is considered
solved by this function!
</td></tr></tbody></table>

</p><p>

<b>Hints</b>

</p><p>

To implement the above, use list comprehensions! Also, the following standard
Haskell functions might come in handy:

</p><pre>replicate :: Int -&gt; a -&gt; [a]
length    :: [a] -&gt; Int
and       :: [Bool] -&gt; Bool
</pre>

To help you get started, here is a file that you can use:

<menu>
<p></p><li><a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/Sudoku.hs">Sudoku.hs</a>, with some definitions that help you
get going with Assignments A, B and C.
</li></menu>

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Reading and Printing Sudokus</font><br>
<p>

Next, we need to have a way of representing Sudokus in a file. In that way, our
program can read Sudokus from a file, and it is easy for us to create and store
several Sudoku puzzles.

</p><p>

The following is an example text-representation that we will use in this
assignment. It actually represents the example above.

</p><pre>36..712..
.5....18.
..92.47..
....13.28
4..5.2..9
27.46....
..53.89..
.83....6.
..769..43
</pre>

There are 9 lines of text in this representation, each corresponding to a row.
Each line contains 9 characters. A digit 1 -- 9 represents a filled cell, and a
period (.) represents a blank cell.

<p>

<b>Assignment B</b>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>B1.</b> Implement a function:
<pre>  printSudoku :: Sudoku -&gt; IO ()
</pre>
that, given a Sudoku, creates instructions to print the Sudoku on the screen,
using the format shown above.
<p>
Example:
</p><pre>  <b>Sudoku&gt;</b> <em>printSudoku allBlankSudoku</em>
  .........
  .........
  .........
  .........
  .........
  .........
  .........
  .........
  .........
  <b>Sudoku&gt;</b> <em>printSudoku example</em>
  36..712..
  .5....18.
  ..92.47..
  ....13.28
  4..5.2..9
  27.46....
  ..53.89..
  .83....6.
  ..769..43
</pre>
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>B2.</b> Implement a function:
<pre>  readSudoku :: FilePath -&gt; IO Sudoku
</pre>
that, given a filename, creates instructions that read the Sudoku from the
file, and deliver it as the result of the instructions. You may decide yourself
what to do when the file does not contain a representation of a Sudoku.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>do sud &lt;- readSudoku "example.sud"; printSudoku sud</em>
  36..712..
  .5....18.
  ..92.47..
  ....13.28
  4..5.2..9
  27.46....
  ..53.89..
  .83....6.
  ..769..43
  <b>Sudoku&gt;</b> <em>readSudoku "Sudoku.hs"</em>
  Program error: Not a Sudoku!
</pre>
</td></tr></tbody></table>

</p><p>

<b>Hints</b>

</p><p>

To implement the above, you will need to be able to convert between characters
(type <b>Char</b>) and digits/integers (type <b>Int</b>). The standard functions
<b>chr</b> and <b>ord</b> (import the module <b>Data.Char</b>) will come in handy
here. Think about the following problems:
</p><menu>
<li>Given a character representing a digit, for example '3' :: Char. How do you compute
the integer value 3?
</li><li>Given a digit represented as an integer, for example 3 :: Int. How do
you compute the character '3'?
</li></menu>
The constant value <b>ord '0'</b> will play a central role in all this.

<p>

Here are some functions that might come in handy:

</p><pre>chr       :: Int -&gt; Char
ord       :: Char -&gt; Int
putStr    :: String -&gt; IO ()
putStrLn  :: String -&gt; IO ()
sequence_ :: [IO a] -&gt; IO ()
readFile  :: FilePath -&gt; IO String
lines     :: String -&gt; [String]
</pre>

Here are some example Sudoku-files that you can download and use:

<menu>
<p></p><li><a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/example.sud">example.sud</a>, containing the above example.
<p></p></li><li><a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/sudokus.zip">sudokus.zip</a>, a ZIPped collection of sudokus,
both easy and hard ones. The easy ones should all be solvable by your final program
within minutes; the hard ones will probably take a very long time (unless you do
extra Assignment X and/or Y)!.
</li></menu>

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Generating Sudokus as Test Data</font><br>
<p>

Finally, we need to be able to test properties about the functions related to
our Sudokus. In order to do so, QuickCheck needs to be able to generate
arbitrary Sudokus.

</p><p>

Let us split this problem into a number of smaller problems. First, we need to
know how to generate arbitrary cell values (of type <b>Maybe Int</b>). Then,
we need to know how to generate 81 such cells, and compose them all into a
Sudoku.

</p><p>
<b>Assignment C</b>
</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>C1.</b> Implement a function:
<pre>  cell :: Gen (Maybe Int)
</pre>
that, contains instructions for generating a Sudoku cell. You have to think
about the following:
<menu>
<li>Cells either contain a digit between 1 and 9 (for example <b>Just 3</b>) or
are empty (<b>Nothing</b>),
</li><li>We would like our generated Sudokus to resemble realistic Sudoku puzzles.
Therefore, the distribution should be around 10% probability non-empty cells
vs. 90% probability for empty cells. (This is not something strict; you can play
around with this if you like.)
</li></menu>
<p>
Example:
</p><pre>  <b>Sudoku&gt;</b> <em>sample cell</em>
  Just 3
  Nothing
  Nothing
  Just 7
  Nothing
</pre>
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>C2.</b> Make Sudokus an instance of the class Arbitrary.
<pre>  <b>instance</b> Arbitrary Sudoku <b>where</b>
    ...
</pre>
We have already done this for you in the file
<a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/Sudoku.hs">Sudoku.hs</a>.
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>C3.</b> Define a property
<pre>  prop_Sudoku :: Sudoku -&gt; Bool
</pre>
that expresses that each generated Sudoku actually is a Sudoku according 
to
Assignment A2. Also use QuickCheck to check that the property 
actually holds for all Sudokus that are generated.
</td></tr></tbody></table>

</p><p>

<b>Hints</b>

</p><p>

Here are some functions that might come in handy:

</p><pre>sample    :: Show a =&gt; Gen a -&gt; IO ()
choose    :: Random a =&gt; (a,a) -&gt; Gen a
frequency :: [(Int,Gen a)] -&gt; Gen a
sequence  :: [Gen a] -&gt; Gen [a]
</pre>

You might want to take a look at the lecture notes and example code on test data
generation.

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Rows, Columns, Blocks</font><br>
<p>

Now, we are going to think about what actually constitutes a valid solution of a
Sudoku. There are three constraints that a valid solution has to forfill:

</p><menu>
<p></p><li>No row can contain the same digit twice;
<p></p></li><li>No column can contain the same digit twice;
<p></p></li><li>No 3x3 block can contain the same digit twice.
</li></menu>

This leads us to the definition of a <em>block</em>; a block is either a row or
a column or a 3x3 block. A block therefore contains 9 cells:
<pre>  <b>type</b> Block = [Maybe Int]
</pre>

We are going to define a function that checks if a Sudoku is not violating any
of the above constraints, by checking that none of the blocks violate those
constraints.

<p>
<b>Assignment D</b>
</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>D1.</b> Implement a function:
<pre>  isOkayBlock :: Block -&gt; Bool
</pre>
that, given a block, checks if that block does not contain the same digit twice.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>isOkayBlock [Just 1, Just 7, Nothing, Nothing, Just 3, Nothing, Nothing, Nothing, Just 2]</em>
  True
  <b>Sudoku&gt;</b> <em>isOkayBlock [Just 1, Just 7, Nothing, Just 7, Just 3, Nothing, Nothing, Nothing, Just 2]</em>
  False
</pre>
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>D2.</b> Implement a function:
<pre>  blocks :: Sudoku -&gt; [Block]
</pre>
that, given a Sudoku, creates a list of all blocks of that Sudoku. This means:
<menu>
<li>9 rows,
</li><li>9 columns,
</li><li>9 3x3 blocks.
</li></menu>
<p>
Also add a property that states that, for each Sudoku, there are 3*9 blocks,
and each block has exactly 9 cells.
</p></td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>D3.</b> Now, implement a function:
<pre>  isOkay :: Sudoku -&gt; Bool
</pre>
that, given a Soduko, checks that all rows, colums and 3x3 blocks do not contain
the same digit twice.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>isOkay allBlankSudoku</em>
  True
  <b>Sudoku&gt;</b> <em>do sud &lt;- readSudoku "example.sud"; print (isOkay sud)</em>
  True
</pre>
</td></tr></tbody></table>

</p><p>

<b>Hints</b>

</p><p>

Here are some functions that might come in handy:

</p><p>

</p><pre>nub       :: Eq a =&gt; [a] -&gt; [a]
transpose :: [[a]] -&gt; [[a]]
take      :: Int -&gt; [a] -&gt; [a]
drop      :: Int -&gt; [a] -&gt; [a]
</pre>

Note that some of the above functions only appear when you import
<b>Data.List</b>.

<p>
You might want to take a look at the exercises and answers on lists and list
comprehensions.

<!-- -------------------------------------------------------------------- -->

</p><p><br></p><hr>
<font size="+2">Positions and Finding Blanks</font><br>
<p>

We are getting closer to the final solving function. Let us start thinking about
how such a function would work.

</p><p>

Given a Sudoku, if there are no blanks left in the Sudoku, we are done.
Otherwise, there is at least one blank cell that needs to be filled in somehow.
We are going to write functions to find and manipulate blank cells.

</p><p>

It is quite natural to start to talk about <em>positions</em>. A position is a
coordinate that identifies a cell in the Sudoku. Here is a way of modelling
coordinates:

</p><pre>  <b>type</b> Pos = (Int,Int)
</pre>

We use positions as indicating first the row and then the column.
For example, the position (3,5) denotes the 5th cell in the 3rd row.

<p>

Note: It is common in programming languages to start counting at 0! Therefore,
the position that indicates the upper left corner is (0,0), and the position
indicating the lower right corner is (8,8).

</p><p>

</p><p>
<b>Assignment E</b>
</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>E1.</b> Implement a function:
<pre>  blanks :: Sudoku -&gt; [Pos]
</pre>
that, given a Sudoku  returns a list of the positions in the
Sudoku that are still blank. You may decide on the order in which the 
positions appear.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>length (blanks allBlankSudoku) == 9*9</em>
  True
  <b>Sudoku&gt;</b> <em>blanks example</em>
  [(0,2),(0,3),(0,7),(0,8),(1,0),(1,2),(1,3),(1,4),(1,5),(1,8),(2,0),(2,1),
   (2,4),(2,7),(2,8),(3,0),(3,1),(3,2),(3,3),(3,6),(4,1),(4,2),(4,4),(4,6),
   (4,7),(5,2),(5,5),(5,6),(5,7),(5,8),(6,0),(6,1),(6,4),(6,7),(6,8),(7,0),
   (7,3),(7,4),(7,5),(7,6),(7,8),(8,0),(8,1),(8,5),(8,6)]
</pre>
In addition, write a property that states that all cells in the blanks list 
are actually blank.
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>E2.</b> Implement a function:
<pre>  (!!=) :: [a] -&gt; (Int,a) -&gt; [a]
</pre>
that, given a list, and a tuple containing an index in the list and a new value,
updates the given list with the new value at the given index.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>["a","b","c","d"] !!= (1,"apa")</em>
  ["a","apa","c","d"]
  <b>Sudoku&gt;</b> <em>["p","qq","rrr"] !!= (0,"bepa")</em>
  ["bepa","qq","rrr"]
</pre>
Also write (a) propert(y/ies) that state(s) the expected properties of this
function. Think about what can go wrong!
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>E3.</b> Implement a function:
<pre>  update :: Sudoku -&gt; Pos -&gt; Maybe Int -&gt; Sudoku
</pre>
that, given a Sudoku, a position, and a new cell value, updates the given Sudoku
at the given position with the new value.
<p>
Example:
</p><pre>  <b>Sudoku&gt;</b> <em>printSudoku (update allBlankSudoku (1,3) (Just 5))</em>
  .........
  ...5.....
  .........
  .........
  .........
  .........
  .........
  .........
  .........
</pre>
Also write a property that checks that the updated position really has gotten
the new value.
</td></tr></tbody></table>
</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>E4.</b> Implement a function:
<pre>  candidates :: Sudoku -&gt; Pos -&gt; [Int]
</pre>
that, given a Sudoku, and a blank position, determines which numbers could be
legally written into that position.
<p>
Example:
</p><pre>  <b>Sudoku&gt;</b> <em>candidates example (0,2)</em>
[4,8]
 <b>Sudoku&gt;</b> <em>candidates allBlankSudoku (8,8)</em>
[1,2,3,4,5,6,7,8,9]
</pre>
In addition, write a property that relates the function candidates with the functions update, isSudoku, and isOkay. (This property can be very useful to understand how to solve Sudokus!)
</td></tr></tbody></table>
</p><p>

<b>Hints</b>

</p><p>

There is a standard function <b>(!!)</b> in Haskell for getting a specific
element from a list. It starts indexing at 0, so for example to get the
first element from a list xs, you can use xs !! 0.

</p><p>

We usually use the standard function <b>zip</b> to pair up elements in a list
with their corresponding index. Example:
</p><pre>  <b>Prelude&gt;</b> <em>["apa","bepa","cepa"] `zip` [1..3]</em>
  [("apa",1),("bepa",2),("cepa",3)]
</pre>
This, in combination with list comprehensions, should be very useful for this
assignment!

<p>

When testing a property that is polymorphic (meaning that it has type variables
in its type), you need to add a type signature that picks an arbitrary type. For
example, when testing properties for the function (!!=), which works for lists
of any type, you have to fix the type when testing, for example lists of
Integers. Do this by adding a type signature to your properties.

</p><p>

Here are some more useful functions:

</p><pre>head :: [a] -&gt; a
(!!) :: [a] -&gt; Int -&gt; a
zip  :: [a] -&gt; [b] -&gt; [(a,b)]
</pre>


<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Solving Sudokus</font><br>
<p>

Finally, we have all the bits in place to attack our main problem: Solving a
given Sudoku.

</p><p>

Our objective is to define a Haskell function
</p><pre>  solve :: Sudoku -&gt; Maybe Sudoku
</pre>
The basic idea is as follows. Function solve must first check that its argument
is not already a bad Sudoku. This means that (1) it represents a 9x9 sudoku, (2) it has no blocks
(rows, columns, 3x3 blocks) that contain the same digit twice.
We will only do this check once. If the argument is bad then 
solve must return <b>Nothing</b>
<p>
Now if we have such a Sudoku <b>sud</b> that we would like to solve, we give it to a recursive helper function <b>solve'</b>. 
</p><p>
The <b>solve'</b> function must 
consider all the blanks in <b>sud</b>. If this list is empty then 
by (1) and (2) above we are done, and the answer of <b>solve'</b> (and hence <b>solve</b>) 
must be <b>Just sud</b>. 
</p><p> 
Otherwise there is at least one blank position. We choose one of them. 
<!-- It makes sense to choose a blank with a minimum number of candidates. 
  -->
For this blank position we 
we try to <em>recursively</em> solve <b>sud</b>, once for each possible candidate; in each recursive case we update the
blank cell with a candidate. The first recursive attempt that
does not give <b>Nothing</b> provides our solution. But if none of the recursive attempts succeed, we return
<b>Nothing</b>.

This method of problem solving is called
<a href="http://en.wikipedia.org/wiki/Backtracking">backtracking</a>.



</p><p>
<b>Assignment F</b>
</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>F1.</b> Implement a function:
<pre>  solve :: Sudoku -&gt; Maybe Sudoku
</pre>
using the above idea.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>printSudoku (fromJust (solve allBlankSudoku))</em>
  123456789
  456789123
  789123456
  214365897
  365897214
  897214365
  531642978
  642978531
  978531642
  <b>Sudoku&gt;</b> <em>do sud &lt;- readSudoku "example.sud"; printSudoku (fromJust (solve sud))</em>
  364871295
  752936184
  819254736
  596713428
  431582679
  278469351
  645328917
  983147562
  127695843
  <b>Sudoku&gt;</b> <em>do sud &lt;- readSudoku "impossible.sud"; print (solve sud)</em>
  Nothing
</pre>
(In the above examples, we use the standard function <b>fromJust</b> from the library
<b>Data.Maybe</b>.)
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>F2.</b> For your own convenience, define a function:
<pre>  readAndSolve :: FilePath -&gt; IO ()
</pre>
that produces instructions for reading the Sudoku from the given file, solving it, and printing the answer.
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>readAndSolve "example.sud"</em>
  364871295
  752936184
  819254736
  596713428
  431582679
  278469351
  645328917
  983147562
  127695843
  <b>Sudoku&gt;</b> <em>readAndSolve "impossible.sud"</em>
  (no solution)
</pre>
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>F3.</b> Implement a function:
<pre>  isSolutionOf :: Sudoku -&gt; Sudoku -&gt; Bool
</pre>
that checks, given two Sudokus, whether the first one is a solution (i.e. all blocks
are okay, there are no blanks), and also whether the first one is a solution of the
second one (i.e. all digits in the second sudoku are maintained in the first one).
<p>
Examples:
</p><pre>  <b>Sudoku&gt;</b> <em>fromJust (solve allBlanksSudoku) `isSolutionOf` allBlanksSudoku</em>
  True
  <b>Sudoku&gt;</b> <em>allBlankSudoku `isSolutionOf` allBlanksSudoku</em>
  False
  <b>Sudoku&gt;</b> <em>fromJust (solve allBlankSudoku) `isSolutionOf` example</em>
  False
</pre>
</td></tr></tbody></table>

</p><p>

<table width="100%" bgcolor="#DDDDDD"><tbody><tr><td>
<b>F4.</b> Define a property:
<pre>  prop_SolveSound :: Sudoku -&gt; Property
</pre>
that says that the function <b>solve</b> is <em>sound</em>. Soundness means that every
supposed solution
produced by <b>solve</b> actually is a valid solution of the original problem.
</td></tr></tbody></table>

</p><p>

<b>Hints</b>

</p><p>

All the work we did in the assignments A -- E should be used in order to implement
the function <b>solve</b>.

</p><p>

QuickChecking the property <b>prop_SolveSound</b> will probably take a long time. Be patient!
Alternatively, there are a number of things you can do about this.
</p><menu>
<p></p><li>You can test on fewer examples (using the QuickCheck function
quickCheckWith). You can for example define:
<!-- 
 <B>check</B> and
the type <B>Config</B>). You can for example define (using QuickCheck 1.x):
<pre>
  fewerCheck prop = check defaultConfig{ configMaxTest = 20 } prop
</pre>
or with QuickCheck 2.x: 
 -->
<pre>  fewerChecks prop = quickCheckWith stdArgs{ maxSuccess = 30 } prop
</pre>
and then write <b>fewerChecks prop_SolveSound</b> when you want to QuickCheck the property.
<p></p></li><li>You can also generate Sudokus with a different probability distribution. Try increasing
the amount of digits in an arbitrary Sudoku by fiddling with the frequencies in the <b>cell</b> function
from Assignment C1 and see what happens.
<p></p></li><li>You can use a compiler, such as <a href="http://www.haskell.org/ghc">GHC</a>. 
</li></menu>
It is okay if you do not find a completely satisfactory solution to this issue.
<p>

Here are some useful functions:

</p><pre>fromJust    :: Maybe a -&gt; a
listToMaybe :: [a] -&gt; Maybe a
catMaybes   :: [Maybe a] -&gt; [a]
</pre><p>

Here is an example of an impossible Sudoku:

</p><menu>
<p></p><li><a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/impossible.sud">impossible.sud</a>
</li></menu>

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<font size="+2">Extra Assignments (for fun)</font><br>
<p>

Just for fun. You can choose freely whether to do 0, 1 or more of these.
Don't expect us to spend time grading these however. 
There are no perfect, pre-defined answers here.
</p><ul>
<li>
<a href="http://www.cse.chalmers.se/edu/year/2012/course/TDA452/labs/3/extra.html">Bring it on!</a>
</li></ul>

<!-- -------------------------------------------------------------------- -->

<p><br></p><hr>
<a name="note"><font size="+2">Submission</font></a><br>
<p>

Submit your solutions using the Fire system.

</p><p>

Your submission should consist of the following file:

</p><menu>
<p></p><li><b>Sudoku.hs</b>, containing your solution. 
It should contain enough comments to understand what is going 
on.
</li></menu>

<!-- <P>

<TABLE WIDTH='100%'><TR BGCOLOR="#DDDDDD"><TD>
<B>Note:</B> You do NOT have to use zip/gzip/tar/bzip on your files! We 
have switched this Fire "feature" off. Just upload and then submit each 
file that is part of your solution.
</TD></TR></TABLE>

<P>
--> 
Before you submit your code, Clean It Up! Remember, submitting clean code
is Really Important, and simply the polite thing to do. After you feel you are done,
spend some time on cleaning your code; make it simpler, remove unneccessary things, etc.
We will reject
your solution if it is not clean. Clean code:

<menu>
<p></p><li>Does not have long lines (&lt; 78 characters)
<p></p></li><li>Has a consistent layout
<p></p></li><li>Has type signatures for all top-level functions
<p></p></li><li>Has good comments
<p></p></li><li>Has no junk (junk is unused code, commented code, unneccessary comments)
<p></p></li><li>Has no overly complicated function definitions
<p></p></li><li>Does not contain any repetitive code (copy-and-paste programming)
</li></menu>

<p>

<a href="https://fire.cs.chalmers.se:8073/cgi/Fire-fp"><b>To the Fire System</b></a>

Good Luck!

</p><p>

<!-- ---------------------------------------------------------------------- -->
<table width="100%" bgcolor="#BBBBBB" border="0" cellpadding="5">
<tbody><tr bgcolor="#BBBBBB">
<td align="right">
Lab written and developed by 
<a href="http://www.cs.chalmers.se/~koen/">Koen Lindström Claessen</a>
</td></tr>
</tbody></table>




<!-- ---------------------------------------------------------------------- -->
</p></body></html>